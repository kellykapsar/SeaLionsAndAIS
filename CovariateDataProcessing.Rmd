---
title: "Covariate Data Processing"
author: "Kelly Kapsar"
date: "11/9/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Import libraries. 
```{r message=FALSE, warning=FALSE}

library(sf)
library(raster)
library(ggplot2)
library(marmap)
library(ncdf4)
library(anytime)

```

Study area boundaries. 

```{r warning=FALSE}
# Location of study area shape file on my computer
study <- read_sf("../Data_Raw/DraftSeaLionAOI_Envelope_20kmBuff_6334.shp")
basemap <- read_sf("../Data_Raw/BBmap.shp") %>% st_transform(6334) %>% st_buffer(0)

# Projection information for NAT83/UTM Zone 5N (EPSG:6334)
prj <- "+proj=utm +zone=5 +ellps=GRS80 +units=m +no_defs"

# Crop basemap to buffered extent of study area 
study.buff <- st_buffer(study, 100000) # Buffer study area by 100 km
basemap.crop <- st_crop(basemap, study.buff)

# Map of study area 
ggplot() +
  geom_sf(data=basemap.crop, fill="gray", color="black", lwd=0.5) +
  geom_sf(data=study, fill=NA, color="red")

# Get latlong coordinates for study area for use in downloading other data sets
studylatlon <- study %>% st_transform(4269) %>% st_bbox()
```

## Sea Lion location geodatabase

```{r sea lion gdb processing}
# Import sea lion location geodatabase (downloaded from Google Drive folder)
seali <- st_layers("../Data_Raw/locs_depths_temps_geodbase_20201130.gdb")
seali$name # list of layers 

# Determine all layers of interest within gdb 
lyrs <- grep("_locs_dives", seali$name)

# Create initial sf object with data from one sea lion 
sealis <- st_read("../Data_Raw/locs_depths_temps_geodbase_20201130.gdb",
                    layer=seali$name[lyrs[1]])

# Remove that layer from the layers of interest list
lyrs <- lyrs[2:length(lyrs)]

# Append all other layers of interest onto the main location data set 
for(i in lyrs){
  temp <- st_read("../Data_Raw/locs_depths_temps_geodbase_20201130.gdb",
                    layer=seali$name[i])
  sealis <- rbind(sealis, temp)
}

# Remove points outside the study area
sealis$inbounds <- lengths(st_within(sealis, st_transform(study, 4326)))
sealis <- sealis[which(sealis$inbounds == TRUE),]

############ CHECK ON THIS ###############
# 40 Duplicated rows (excluding geometry column)
test <- duplicated(data.frame(sealis))
# Remove duplicated rows 
sealis <- sealis[which(duplicated(data.frame(sealis))==FALSE),]

# Transform geometry to correct projection 
st_geometry(sealis) <- st_transform(st_geometry(sealis),prj)

# Map of study area 
ggplot() +
  geom_sf(data=basemap.crop, fill="gray", color="black", lwd=0.5) +
  geom_sf(data=study, fill=NA, color="red")+
  geom_sf(data=sealis, aes(color=DurationMax))

``` 


## Bathymetry 

Bathymetry data were collected from the [General Bathymetric Chart of the Oceans](gebco.net). You can use the marmap package to load the data and create a "bathy" object type, but I'm not sure exactly how to work with that kind of object, so I just imported the tif data and converted into a raster.    

```{r bathymetry, warning=FALSE}

# bathymarmap <- marmap::readGEBCO.bathy("../Data_Raw/GEBCO_2020_09_Nov_2020_nc/gebco_2020_n61.0_s55.0_w-155.0_e-147.0.nc")

# Import raster, reproject to 4336, and crop to study area
bathy <- raster::raster("../Data_Raw/GEBCO_2020_09_Nov_2020_tif/gebco_2020_n61.0_s55.0_w-155.0_e-147.0.tif") %>% projectRaster(crs=prj) %>% raster::crop(study)

bathyDf <- as.data.frame(bathy, xy=TRUE) 
colnames(bathyDf) <- c("x","y","depth")

# Save raster object 
# raster::writeRaster(bathy, "../Data_Processed/bathemtry_GEBCO_cropped_4336.tif")

# Map of study area with bathymetric data 
ggplot() +
  geom_sf(data=basemap.crop, fill="gray", color="black", lwd=0.5) +
  geom_raster(data=bathyDf, aes(x=x, y=y, fill=depth), alpha=0.9) +
  scale_fill_gradient2() +
  geom_sf(data=study, fill=NA, color="red")

```

## Sea Surface Temperature

[OSTIA: Operational Sea Surface Temperature and Sea Ice Analysis](https://portal.aoos.org/gulf-of-alaska.php#module-metadata/e873784f-7201-416f-bb26-6061c82af388/adc56dd8-e6c6-4d09-abc6-86962fc308eb) from the Alaska Ocean Observing System. 

Citation: 	UK Met Office. 2005. OSTIA L4 SST Analysis. Ver. 1.0. PO.DAAC, CA, USA. Dataset accessed [YYYY-MM-DD] at https://doi.org/10.5067/GHOST-4FK01

Data requested from: https://thredds.axiomdatascience.com/thredds/ncss/AOOS_OSTIA.nc/dataset.html
Variables = analysed_sst, analysis_error, mask, sea_ice_fraction

North = 61
South = 55
West = -156
East = -147
Start = 01 Nov 2018
End = 31 May 2020

NCSS Request URL: https://thredds.axiomdatascience.com/thredds/ncss/AOOS_OSTIA.nc?var=analysed_sst&var=analysis_error&var=mask&var=sea_ice_fraction&north=61&west=-156&east=-147&south=55&horizStride=1&time_start=2018-11-01T12%3A00%3A00Z&time_end=2020-05-31T12%3A00%3A00Z&timeStride=1&accept=netcdf

```{r sea surface temperature}

# Open netcdf file 
sst <- nc_open("../Data_Raw/AOOS_OSTIA.nc")
# Save metadata to a text file
{
  sink('../Data_Raw/AOOS_OSTIA.txt')
  print(sst)
  sink()
}

# Read lat lon and time for each observation
lon <- ncvar_get(sst, "lon")
lat <- ncvar_get(sst, "lat", verbose = F)
t <- ncvar_get(sst, "time")

head(lon)

# Read in data from the SST variable and verify the dimensions of the array
sst.array <- ncvar_get(sst, "analysed_sst") # 3dim array
dim(sst.array)

# Identify fill value and replace with NA
fillvalue <- ncatt_get(sst, "analysed_sst","_FillValue")
fillvalue

sst.array[sst.array == fillvalue$value] <- NA

# Close netcdf file
nc_close(sst)

# Isolate and plot a random time step to check
sst.slice <- sst.array[,,1]

dim(sst.slice) #2dim

sst.r <- raster(t(sst.slice), xmn=min(lon), xmx=max(lon), ymn=min(lat),ymx=max(lat),
                # Found projection on the website
                crs=CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs ")) %>%
         flip(direction="y") %>%
         raster::projectRaster(crs=prj) %>%
         raster::crop(study)

sst.df <- as.data.frame(sst.r, xy=TRUE)
colnames(sst.df) <- c("x","y","sst")

plot(sst.r)

# Map of study area with sst data
ggplot() +
  geom_sf(data=basemap.crop, fill="gray", color="black", lwd=0.5) +
  geom_raster(data=sst.df, aes(x=x, y=y, fill=sst), alpha=0.9) +
  scale_fill_gradient2() +
  geom_sf(data=study, fill=NA, color="red")

# Make a raster brick of all values 
sst_brick <- brick(sst.array, xmn=min(lon), xmx=max(lon), ymn=min(lat), ymx=max(lat), 
                crs=CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")) %>% 
         flip(direction="x") %>%
         raster::projectRaster(crs=prj) %>% 
         raster::crop(study)

# Convert date from seconds since 01/01/1970 to yyyy-mm-dd format
t <- anydate(t)
class(t)
# Name raster layers after the date that they portray
names(sst_brick) <- format(t, "X%Y.%m.%d")

# Save output file
# writeRaster(sst_brick, "../Data_Processed/SST_AOOS_cropped_4336.tif")

# Fun animation of the raster brick
# animate(sst_brick, pause=0.5, n=1)

# Calculate the change between any two layers
# tempchange <- sst_brick[[2]]-sst_brick[[1]]
# tempchange

# Calculate mean monthly SST rasters 

#get the date from the names of the layers and extract the month
indices <- format(as.Date(names(sst_brick), format = "X%Y.%m.%d"), format = "%Y%m")
indices <- as.numeric(indices)

#sum layers
sst_month <- stackApply(sst_brick, indices, fun = mean)
#animate(sst_month, pause=0.5, n=1)

```
I used this tutorial on indexing [raster time series](https://cyberhelp.sesync.org/raster-time-series-alaska-lesson/index.html#/slides/brick)

For calculating monthly mean values in a [raster brick](https://gis.stackexchange.com/questions/237272/mean-by-month-on-r-stacked-raster). 

```{r merging sea lion locs with SST data}

# Put seali date into same format as raster brick names
sealis$yearmon <- format(sealis$Date_, format="%Y%m")

# Extract monghtly average values for SST at seali locs
for(i in 1:length(sealis$DeployID)){
  if(i %% 100 == 0){
    print(i)
  }
   sealis$SST[i] <- extract(subset(sst_month, 
                                   paste0("index_",sealis$yearmon[i])), sealis[i,])
}

# Looking at the data 
hist(sealis$SST)
length(which(is.na(sealis$SST)))
length(unique(sealis$SST))


# # SST over time at a particular location 
# idx <- match('Aug.13.2019', names(sst_brick))
# plot(sst_brick[[idx]])

```

