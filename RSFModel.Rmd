---
title: "RSFModel"
author: "Kelly Kapsar"
date: "8/19/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Import libraries. 

```{r message=FALSE, warning=FALSE}
library(tidyr)
library(dplyr)
library(sf)
library(raster)
library(ggplot2)
library(scales)
library(ggmap)
library(leaflet)

```

Study area boundaries. 

```{r study area warning=FALSE}
# Projection information for WGS84/UTM Zone 5N (EPSG:32605)
prj <- 32605

# Create study area polygon
coords <- data.frame(lat=c(56, 62, 62, 56, 56), lon=c(-155, -155, -143, -143, -155), id="study")
study <- coords %>% 
         st_as_sf(coords = c("lon", "lat"), crs=4326) %>% 
         group_by(id) %>% 
         summarize(geometry = st_combine(geometry)) %>%  
         st_cast("POLYGON") %>% 
         st_transform(prj)
# st_write(study, "../Data_Raw/studyarea.shp")

basemap <- read_sf("../Data_Raw/BBmap.shp") %>% st_transform(prj) %>%  st_buffer(0)

# Crop basemap to buffered extent of study area 
study.buff <- st_buffer(study, 100000) # Buffer study area by 100 km
basemap.crop <- st_crop(basemap, study.buff)

# Map of study area 
ggplot() +
  geom_sf(data=basemap.crop, fill="gray", color="black", lwd=0.5) +
  geom_sf(data=study, fill=NA, color="red")

# Get latlong coordinates for study area for use in downloading other data sets
studylatlon <- study %>% st_transform(4269) %>% st_bbox()

```

Defining used and available locations.

```{r}

# Read in covariates 
landmask <- raster("../Data_Processed/Landmask_GEBCO.tif")
dist500m <- raster("../Data_Processed/Dist500m.tif") %>% raster::mask(landmask, maskvalue=1)
depth <- raster("../Data_Processed/Bathymetry.tif") %>% raster::mask(landmask, maskvalue=1)
distland <- raster("../Data_Processed/DistLand.tif") %>% raster::mask(landmask, maskvalue=1)
covarstack <- raster::stack(distland, dist500m, depth)

ship <- readRDS("../Data_Processed/AIS_AllOther.rds")
fish <- readRDS("../Data_Processed/AIS_Fishing.rds")


used <- readRDS("../Data_Processed/watersealis.rds")
usedbuff <- readRDS("../Data_Processed/watersealibuffs.rds")

# Create functions 
custom_extract_avail <- function(usedbuff, covarstack, npts = 5){
  df <-  as.data.frame(sampleRandom(x=covarstack, size = npts, na.rm = TRUE, ext = as(usedbuff, "Spatial"), xy = TRUE))
  df$Used <- 0
  df$Date <- usedbuff$Date
  df$DeployID <- usedbuff$DeployID
  return(df)
}

custom_extract_used <- function(used, distland, dist500m, depth){
  pts <- st_as_sf(df, coords = c("x", "y"), crs=st_crs(used))
  pts$Used <- 0
  pts$Date <- used$Date
  pts$DeployID <- used$DeployID
  pts$Distland <- raster::extract(distland, as(pts, "Spatial"), cellnumbers=F)
  pts$Dist500m <- raster::extract(dist500m, as(pts, "Spatial"), cellnumbers=F)
  pts$Depth <- raster::extract(depth, as(pts, "Spatial"), cellnumbers=F)
  return(pts)
}

# Runing function as a loop takes ~15 hrs.... 
start <- proc.time()
q <- lapply(1:length(usedbuff$DeployID), 
            function(x){custom_extract_avail(usedbuff[x,], covarstack=p)})
q <- do.call(rbind, q)
proc.time()-start


### Spatiotemporal extract using amt package
library(amt)

trk <- mk_track(st_drop_geometry(used), .x=lon, .y=lat, .t=Date, id = DeployID, 
                crs = CRS("+init=epsg:4326"))
trk.class<-class(trk)

# Calculate time of day based on lat/lon and timestamp
trk <- trk %>% time_of_day()
class(trk) <- trk.class

#' Now, we can transform back to geographic coordinates
trk <- amt::transform_coords(trk, CRS("+init=epsg:32605"))

# ID available points

start <- proc.time()
q <- lapply(1:length(used$DeployID), function(x){random_points(st_buffer(used[x,], dist=used$radius[x]), n=5)})
avail <- do.call(rbind, q)
proc.time()-start


test <- do.call(rbind, test)

test2 <- extract_covariates_var_time(trk, fish, when="any", max_time= days(16))
test <- extract_covariates_var_time(trk, ship, when="any", max_time= days(16))


t <- as.data.frame(amt::extract_covariates(test, covarstack))

temp <- left_join(used, test, by=c("DeployID" = "id", "Date" = "t_"))

test.df <- data.frame(test)




### COPIED FROM AMT PACKAGE
# https://github.com/jmsigner/amt/blob/master/R/extract_covariates.R
# Also helpful: https://cran.r-project.org/web/packages/amt/vignettes/p3_rsf.html

extract_covar_var_time_base <- function(
  xy, t, covariates, when = "any",
  max_diff) {

  if (is.null(raster::getZ(covariates))) {
    stop("Covariates do not have a Z column.")
  }

  if (!is(max_diff, "Period")) {
    stop("`max_diff` is not of class `Period`.")
  }
  max_diff <- lubridate::period_to_seconds(max_diff)
  t_covar <- as.numeric(as.POSIXct(raster::getZ(covariates)))
  t_obs <- as.numeric(as.POSIXct(t))

  # Fun to find closest point
  which_rast <- function(t_diffs, where, max_diff) {
    wr <- if (when == "after") {
      which.min(t_diffs[t_diffs >= 0])
    } else if (when == "before") {
      which.min(abs(t_diffs[t_diffs <= 0])) + sum(t_diffs > 0)
    } else if (when == "any") {
      which.min(abs(t_diffs))
    }
    if (length(wr) == 0) {
      NA
    } else if (max_diff < abs(t_diffs[wr])) {
      NA
    } else {
      wr
    }
  }

  wr <- sapply(t_obs, function(x) which_rast(x - t_covar, when, max_diff))
  ev <- raster::extract(covariates, cbind(xy))
  cov_val <- ev[cbind(seq_along(wr), wr)]
  return(cov_val)
}



t_covar <- as.numeric(as.POSIXct(raster::getZ(fish)))
t_obs <- as.numeric(as.POSIXct(t))
```

